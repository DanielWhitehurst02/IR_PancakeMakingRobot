% Initialize robots and define initial positions
robot1 = UR3e(transl(-0.5, 0.2, 0.5));
robot2 = Panda(transl(0.5, 0.5, 0));
leftFinger1 = Finger();
rightFinger1 = Finger2();
leftFinger2 = Finger();
rightFinger2 = Finger2();

[leftFinger1A, rightFinger1A] = attachGrippersToRobot(robot1,leftFinger1,rightFinger1);
[leftFinger2A, rightFinger2A] = attachGrippersToRobot(robot2,leftFinger2,rightFinger2,troty(-pi/2) * trotz(-pi),transl(0,0.15,0));
%%


% Define end transformations
endTr1 = transl(0, 0.4, 0.5) * troty(pi);
endTr2 = transl(0.3, 0.4, 0.7) * trotx(-pi/2);

% Get the initial transformation matrices for both robots
startTr1 = robot1.model.fkine(robot1.model.getpos()).T;
startTr2 = robot2.model.fkine(robot2.model.getpos()).T;
%%
% Run IK for both robots, passing grippers and transformations
runIKForTwoRobots(robot1, robot2, startTr1, endTr1, startTr2, endTr2, 100, leftFinger1A, rightFinger1A, leftFinger2A, rightFinger2A);

%% Function to Perform IK for Two Robots Simultaneously
function runIKForTwoRobots(robot1, robot2, startTr1, endTr1, startTr2, endTr2, steps, leftFinger1, rightFinger1, leftFinger2, rightFinger2)
    % Calculate initial and final joint configurations for robot1
    qStart1 = robot1.model.ikcon(startTr1);
    qEnd1 = robot1.model.ikcon(endTr1);
    qMatrix1 = jtraj(qStart1, qEnd1, steps);

    % Calculate initial and final joint configurations for robot2
    qStart2 = robot2.model.ikcon(startTr2);
    qEnd2 = robot2.model.ikcon(endTr2);
    qMatrix2 = jtraj(qStart2, qEnd2, steps);

    % Main loop to animate both robots and update grippers step-by-step
    for i = 1:steps
        % Animate robot1 with the current joint configuration
        q_current1 = qMatrix1(i, :);
        robot1.model.animate(q_current1);
        
        % Update gripper positions for robot1
        updateGripperPositionWithEndEffector(robot1, leftFinger1, rightFinger1);
        
        % Animate robot2 with the current joint configuration
        q_current2 = qMatrix2(i, :);
        robot2.model.animate(q_current2);
        
        % Update gripper positions for robot2
        updateGripperPositionWithEndEffector(robot2, leftFinger2, rightFinger2, troty(-pi/2) * trotz(-pi), transl(0, 0.15, 0));
        
        drawnow;  % Force figure update for real-time animation

        % Control the animation speed
        pause(0.01);  % Adjust for smoother animation as needed
    end
end



%% Standalone Function to Attach Grippers to Robot End-Effector
function [leftFinger, rightFinger] = attachGrippersToRobot(robot, leftFinger, rightFinger, gripperRotation, gripperTranslation)
    % Set default rotation and translation if not provided
    if nargin < 4 || isempty(gripperRotation)
        gripperRotation = trotx(pi/2);  % Default rotation
    end
    if nargin < 5 || isempty(gripperTranslation)
        gripperTranslation = transl(0, 0, 0);  % Default translation (no offset)
    end

    disp('Attaching grippers to the robot...');
    
    % Get the current end-effector transformation
    endEffectorTr = robot.model.fkine(robot.model.getpos);

    % Apply rotation and translation to attach the grippers
    leftFinger.model.base = endEffectorTr.T * gripperRotation * gripperTranslation;
    rightFinger.model.base = endEffectorTr.T * gripperRotation * gripperTranslation;

    % Plot the grippers
    leftFinger.PlotAndColourRobot();
    rightFinger.PlotAndColourRobot();

    disp('Grippers successfully attached.');
end

%% Standalone Function to Update Gripper Position with Robot's End Effector
function updateGripperPositionWithEndEffector(robot, leftFinger, rightFinger, gripperRotation, gripperTranslation)
    % Set default rotation and translation if not provided
    if nargin < 4 || isempty(gripperRotation)
        gripperRotation = trotx(pi/2);  % Default rotation
    end
    if nargin < 5 || isempty(gripperTranslation)
        gripperTranslation = transl(0, 0, 0);  % Default translation (no offset)
    end

    % Get the current end-effector transformation
    endEffectorTr = robot.model.fkine(robot.model.getpos);

    % Update the grippers' positions based on end-effector transformation
    leftFinger.model.base = endEffectorTr.T * gripperRotation * gripperTranslation;
    rightFinger.model.base = endEffectorTr.T * gripperRotation * gripperTranslation;

    % Animate the grippers to reflect updated positions
    leftFinger.model.animate(leftFinger.model.getpos);
    rightFinger.model.animate(rightFinger.model.getpos);
end

%% 
function running = checkForCollisionAndPause(collisionHandler, obstaclePoints, running)
    % Update ellipsoid centers based on the current robot configuration
    collisionHandler.drawEllipsoids();

    % Check for collision
    collision = collisionHandler.detectCollision(obstaclePoints);
    if collision
        disp('Collision detected! Pausing robot motion...');
        running = false;  % Stop the robot's motion

        % Pause loop until the collision is cleared
        while collision  % Stay in this loop until the collision is resolved
            pause(0.1);  % Add a small delay to avoid overloading the system
            collisionHandler.drawEllipsoids();  % Update ellipsoid centers
            collision = collisionHandler.detectCollision(obstaclePoints);  % Recheck for collisions

            if ~collision  % Collision resolved
                disp('Collision resolved. Resuming robot motion...');
                running = true;  % Resume robot motion
            end
        end
    end
end

