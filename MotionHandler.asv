classdef MotionHandler
    % MotionHandler handles robot motion control and collision detection

    properties
        collisionHandler
        robot
        RMRC
        obstaclePoints
        running
        obstaclesUpdated
    end

    methods
        % Constructor
        function self = MotionHandler(robot, centerPoints, radii)
            self.robot = robot;
            self.collisionHandler = CollisionEllipsoid(robot, centerPoints, radii);
            self.RMRC = RMRC(robot);
            self.running = true;
            self.obstaclesUpdated = false;
        end

        % Update the obstacle points and check path
        function updateObstacle(self, obstaclePoints)
            % Update the point cloud of obstacles
            self.obstaclePoints = obstaclePoints;
            self.obstaclesUpdated = true;
            % Check the current path for collisions
            self.checkPathCollision();
        end

        % Check if the current path has collisions
        function checkPathCollision(self)
            % Check the RMRC path for any collisions with updated obstacle points
            path = self.RMRC.qMatrix; % Example path, assuming RMRC stores it
            isCollision = self.pathCheck(path);
            if isCollision
                disp('Collision detected on the path after obstacle update.');
            else
                disp('No collision detected on the updated path.');
            end
        end

        % Path collision check function
        function isCollision = pathCheck(self, path)
            % Checks if a given path intersects with any obstacles
            isCollision = false;
            for i = 1:length(path)
                for j = 1:size(self.obstaclePoints, 1)
                    dist = norm(self.obstaclePoints(j, :) - path(i, :)); % 3D distance calculation
                    if dist < 0.1 % Collision threshold
                        isCollision = true;
                        return;
                    end
                end
            end
        end

        % Handle e-stop logic
        function [stopped, currentGoal] = eStop(self)
            % Emergency stop to halt the robot
            self.running = false;
            stopped = true;
            currentGoal = [];
            disp('Emergency stop activated.');
        end

        % Main function to run RMRC with obstacle checking
        function runRMRC(self, startTr, endTr, time, deltaT)
    % Compute RMRC path and run the motion while checking for collisions and eStop

    % Check for eStop status at the beginning of the loop
    if ~self.running
        disp('Operation halted due to e-stop.');
        return;
    end

    % Compute RMRC trajectory
    [s, x, steps] = self.RMRC.ResolvedMotionRateControlPath(startTr, endTr, time, deltaT);

    epsilon = 0.1;  % Manipulability threshold
    W = diag([1 1 1 0.1 0.1 0.1]);  % Weighting matrix

    % Convert the start and end orientations to quaternions
    R_start = startTr(1:3, 1:3);
    R_end = endTr(1:3, 1:3);
    q_start = UnitQuaternion(R_start);  % Create UnitQuaternion from start rotation matrix
    q_end = UnitQuaternion(R_end);      % Create UnitQuaternion from end rotation matrix

    % Loop through each RMRC step
    for i = 1:steps-1
        % Check eStop at the start of each iteration
        if ~self.running
                disp('E-stop triggered during operation.');
                return;
            end

            % Interpolate position and orientation
            pos_interp = transl((1-s(i))*startTr(1:3,4)' + s(i)*endTr(1:3,4)');
            q_interp = q_start.interp(q_end, s(i));  % Interpolate between start and end quaternion
            R_homogeneous = [q_interp.R, [0;0;0]; 0 0 0 1];  % 4x4 matrix
            T_desired = pos_interp * R_homogeneous;

            % Get the current transformation
            T_current = self.robot.model.fkine(self.RMRC.qMatrix(i, :)).T;

            % Compute velocity and Jacobian (using DLS)
            deltaX = T_desired(1:3, 4) - T_current(1:3, 4);
            linear_velocity = deltaX / deltaT;
            angular_velocity = tr2rpy(T_desired(1:3, 1:3) / T_current(1:3, 1:3)) / deltaT;
            xdot = W * [linear_velocity; angular_velocity];

            % Jacobian and DLS for joint velocities
            J = self.robot.model.jacob0(self.RMRC.qMatrix(i, :));
            lambda = 0.01;
            qdot = pinv(J) * xdot;

            % Update joint angles
            self.RMRC.qMatrix(i+1, :) = self.RMRC.qMatrix(i, :) + deltaT * qdot';

            % Check for ellipsoid collision detection
            collision = self.collisionHandler.detectCollision(self.obstaclePoints);
            if collision
                disp('Collision detected! Stopping movement.');
                self.eStop();  % Activate emergency stop
                return;
            end

            % Animate the robot
            self.robot.model.animate(self.RMRC.qMatrix(i+1, :));
            pause(0.05);
            end
        end


        % Function to animate a robot's motion between two poses using ikcon and jtraj
        function runIK(self, startTr, endTr, steps)
            % Check if eStop is active before starting
            if ~self.running
                disp('E-stop is active. Operation halted.');
                return;
            end

            % Initial joint configuration
            q0 = zeros(1, self.robot.model.n);  % Assuming the robot has n degrees of freedom

            % Solve for joint configurations at the start and end transformations
            qStart = self.robot.model.ikcon(startTr, q0);   % Initial pose
            qEnd = self.robot.model.ikcon(endTr, qStart);   % End pose, starting from qStart

            % Generate joint trajectory between the start and end configurations
            qMatrix = jtraj(qStart, qEnd, steps);  % Generate smooth trajectory

            % Animate the robot following the joint trajectory
            for i = 1:steps
                % Check for eStop at each iteration
                if ~self.running
                    disp('E-stop triggered during operation. Halting movement.');
                    return;
                end

                % Get current joint configuration
                q_current = qMatrix(i, :);
                % Animate the robot at the current configuration
                self.robot.model.animate(q_current);
                pause(0.05);  % Adjust the pause duration as needed for smooth animation
            end
        end

    end
end
